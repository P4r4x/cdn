Redis 原理
===

众所周知, Redis 本质上是一个是一种基于**内存**的**高性能低延迟**键值数据库, 接下来尝试分析一下 Redis 高性能的原因;

## 整体架构

### 



## Redis 数据结构

Redis 对其使用的数据类型使用了**高度优化**的数据结构。

---

### 基本数据结构

```c
struct sdshdr {  
    int len;  // buf 中已占用空间的长度  
    int free;  // buf 中剩余可用空间的长度
    char buf[];  // 数据空间  
};
```
- string: **简单动态字符串**;
  
    - 保存了串长, 无需遍历整个字符串来获取长度;
    - 保存剩余空间长度, 防止部分函数如 `strcat()` 发生越界; 如果发生这种情况, 将会先申请空间, 再进行分配;

---

- hash: 可以理解为**运行时动态的变长键值对结构**, 一共有两种储存方式:
    
    - 第一种为 **Ziplist (压缩列表)**, 这种方式连续储存且无指针, 类似 Python `pickle`序列化之后的紧凑排列结构, 遵照 ` prevlen │ encoding │ field │ prevlen │ encoding │ value ` 的这种排列方式; 这种方式**顺序读取**, 减少了指针开销, 非常节省空间。本质上类似于数组结构, 内存利用率高,  适合小规模数据;

    - 第二种为 **Hashtable (哈希表)**, 并且是典型的 **散列表 + 链地址法解决冲突** 型结构。这是一种典型的空间换时间的存储方式, 用内存利用率换取高效率存取, 可能的情况如下:

        ```c
        Hashtable：
            table[0] ──> entry(field1 → value1)
            table[1] ──> NULL
            table[2] ──> entry(field2 → value2) ──> entry(field3 → value3)
        ```

    - hash 的这两种储存方式是可以 (单向) 动态转换的, 当 Redis 尝试存储 hash 时, 会首先尝试使用 Ziplist, 直到 `field-value` 键值对数量超过 512 个*或者*单个 `value` 值超过 64 字节, 该数据将转换为 Hashmap, 这个转换 **不可逆**。

---

- list: 列表, 通过双向链表来实现;

---

- zset: 集合, zset 中的每个元素包含数据本身和一个对应的分数; zset 有两种数据结构
  
  -  数据少时，使用 ziplist, 连续储存, 每项元素都是 (member + score) 的组合, (**每个元素所占空间是可以不同的**, 具体取决于元素大小), 顺序存取, 时间换空间的结构;
  -  数据多时, 采用 **字典 + 跳表 (Dict + Skiplist)**; 简单来说, 字典用来完成 (member → Score), 跳表完成 (Score → member), 且拥有高效率; 这种双向映射维护是为了**高效查找和排序**;
     -   字典内部是哈希表实现的, 也就是说, 给定 member 查找 score 的复杂度为 `O(1)`;
     -   跳表是一个多级查找数据结构, 当给定 score 时, 其查找 member 的时间复杂度是 `O(logn)`, 其实现原理是在原本的**有序单向链表**上, 添加多级索引 (不同于树结构):
    
        > 例如 `1->3->5->7->9->..->19` 可以在 `3, 7, 11, 15, 19` 处添加一级索引, 进一步又可以在 `7` 和 `15` 处添加 2 级索引, 这样一来查找的时候就实现了和树结构类似的多分查找, 提高了效率; (需要额外维护跳表结构, 不过这个维护过程比红黑树等简单;)

     - zset 的数据结构也是变动的, 
- 